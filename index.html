<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Barge Schedule Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.control.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 85vh; }
    .leaflet-control-timecontrol { z-index: 1000; }
    .start-icon { font-size: 20px; color: green; }
    .end-icon { font-size: 20px; transform-origin: center center; }
    .tooltip { background: white; border: 1px solid #ccc; border-radius: 4px; padding: 5px; }
    .header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f5f5f5; border-bottom: 1px solid #ccc; }
    .controls { padding: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .legend { display: flex; gap: 15px; padding: 5px 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; flex-wrap: wrap; }
    .error-message { background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin: 10px; }
  </style>
</head>
<body>
  <div class="header">
    <h2>Barge Schedule Tracker</h2>
    <span>Slide through dates to view barge movements</span>
  </div>
  <div class="controls">
    <button id="playPauseBtn">▶️ Play</button>
    <label>
      Speed:
      <select id="playSpeed">
        <option value="1000">Slow</option>
        <option value="500" selected>Normal</option>
        <option value="250">Fast</option>
        <option value="100">Very Fast</option>
      </select>
    </label>
    <label>
      Filter Barge:
      <select id="bargeFilter">
        <option value="all">All Barges</option>
      </select>
    </label>
    <input type="range" id="timeSlider" style="width: 300px;" />
    <span id="currentTime" style="font-weight: bold;">Loading...</span>
    <div class="legend" id="legend"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.min.js"></script>
  <script>
    // Your actual barge data will be loaded from the JSON file
    const sampleData = [];

    // Initialize map
    const map = L.map('map', {
      zoomControl: false
    });

    // Add base layer
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    }).addTo(map);

    // Move zoom control to top-right
    L.control.zoom({ position: 'topright' }).addTo(map);

    // Colors for barges
    const colors = ['#E74C3C', '#5DADE2', '#4CA61C', '#161CB0', '#FFA500', '#800080', '#FF69B4', '#A52A2A', '#00CED1', '#228B22', '#4682B4', '#FFD700'];

    // Global variables
    let currentData = [];
    let uniqueTimes = [];
    let bargeMarkers = {};
    let bargePaths = {};
    let isPlaying = false;
    let currentTimeIndex = 0;
    let animationTimeout;
    let selectedBarge = 'all';

    function loadData() {
      // Try to fetch actual data, fall back to sample data
      return fetch('/barge_data.json')
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to load barge_data.json');
          }
          return response.json();
        })
        .catch(error => {
          console.warn('Could not load barge_data.json, using sample data:', error);
          return sampleData;
        });
    }

    function processData(data) {
      console.log('Processing data:', data);
      
      if (!data || !Array.isArray(data) || data.length === 0) {
        throw new Error('No valid data available');
      }

      // Convert timestamps and filter invalid positions
      const processedData = data
        .map(d => ({
          ...d,
          Timestamp: new Date(d.Timestamp).toISOString()
        }))
        .filter(d => d.Latitude !== 0 && d.Longitude !== 0 && d.Latitude != null && d.Longitude != null)
        .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));

      // Get unique times
      uniqueTimes = [...new Set(processedData.map(d => d.Timestamp))].sort();
      
      // Get unique barges
      const barges = [...new Set(processedData.map(d => d['Barge Name']))].sort();
      
      // Create color mapping
      const colorDict = {};
      barges.forEach((barge, i) => {
        colorDict[barge] = colors[i % colors.length];
      });

      // Set map center
      const avgLat = processedData.reduce((sum, d) => sum + d.Latitude, 0) / processedData.length;
      const avgLon = processedData.reduce((sum, d) => sum + d.Longitude, 0) / processedData.length;
      map.setView([avgLat, avgLon], 4);

      // Create legend
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      barges.forEach(barge => {
        const span = document.createElement('span');
        span.innerHTML = `<span style="color: ${colorDict[barge]}; font-weight: bold;">■ ${barge}</span>`;
        legend.appendChild(span);
      });

      // Populate barge filter dropdown
      const bargeFilter = document.getElementById('bargeFilter');
      barges.forEach(barge => {
        const option = document.createElement('option');
        option.value = barge;
        option.textContent = barge;
        bargeFilter.appendChild(option);
      });

      // Initialize markers and paths for each barge
      barges.forEach(barge => {
        bargeMarkers[barge] = L.marker([0, 0], {
          icon: L.divIcon({
            className: 'barge-rectangle',
            html: `<div style="
              width: 16px; 
              height: 10px; 
              background-color: ${colorDict[barge]}; 
              border: 1px solid black;
              border-radius: 2px;
            "></div>`,
            iconSize: [16, 10],
            iconAnchor: [8, 5]
          })
        });
        // Don't add to map initially

        bargePaths[barge] = L.polyline([], {
          color: colorDict[barge],
          weight: 3,
          opacity: 0.6
        }).addTo(map);
      });

      return { processedData, barges, colorDict };
    }

    function updateMapForTime(timeIndex) {
      const currentTime = uniqueTimes[timeIndex];
      const currentTimeData = currentData.filter(d => d.Timestamp === currentTime);

      // Hide all markers and paths first
      Object.keys(bargeMarkers).forEach(barge => {
        map.removeLayer(bargeMarkers[barge]);
        if (selectedBarge !== 'all' && selectedBarge !== barge) {
          bargePaths[barge].setStyle({ opacity: 0 });
        } else {
          bargePaths[barge].setStyle({ opacity: 0.6 });
        }
      });

      // Update markers for current time
      currentTimeData.forEach(point => {
        const barge = point['Barge Name'];
        const marker = bargeMarkers[barge];
        
        if (marker && (selectedBarge === 'all' || selectedBarge === barge)) {
          marker.setLatLng([point.Latitude, point.Longitude]);
          marker.addTo(map);
          marker.bindTooltip(`${barge}<br>Step: ${point['Schedule Step'] || 'N/A'}<br>Location: ${point.Location || 'N/A'}<br>Date: ${new Date(point.Timestamp).toLocaleDateString()}`, {
            direction: 'top',
            offset: [0, -10]
          });
        }
      });

      // Update paths (show history up to current time)
      Object.keys(bargePaths).forEach(barge => {
        if (selectedBarge === 'all' || selectedBarge === barge) {
          const bargeHistory = currentData
            .filter(d => d['Barge Name'] === barge && new Date(d.Timestamp) <= new Date(currentTime))
            .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
          
          const pathCoords = bargeHistory.map(d => [d.Latitude, d.Longitude]);
          bargePaths[barge].setLatLngs(pathCoords);
        }
      });

      // Update time display
      document.getElementById('currentTime').textContent = new Date(currentTime).toLocaleDateString();
      document.getElementById('timeSlider').value = timeIndex;
    }

    function setupControls() {
      const timeSlider = document.getElementById('timeSlider');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const playSpeed = document.getElementById('playSpeed');
      const bargeFilter = document.getElementById('bargeFilter');

      // Check if all elements exist
      if (!timeSlider || !playPauseBtn || !playSpeed || !bargeFilter) {
        console.error('One or more control elements not found');
        return;
      }

      timeSlider.min = 0;
      timeSlider.max = uniqueTimes.length - 1;
      timeSlider.value = 0;

      timeSlider.addEventListener('input', (e) => {
        currentTimeIndex = parseInt(e.target.value);
        updateMapForTime(currentTimeIndex);
        if (isPlaying) {
          stopAnimation();
        }
      });

      playPauseBtn.addEventListener('click', () => {
        if (isPlaying) {
          stopAnimation();
        } else {
          startAnimation();
        }
      });

      bargeFilter.addEventListener('change', (e) => {
        selectedBarge = e.target.value;
        updateMapForTime(currentTimeIndex);
      });
    }

    function startAnimation() {
      isPlaying = true;
      document.getElementById('playPauseBtn').textContent = '⏸ Pause';
      animate();
    }

    function stopAnimation() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '▶️ Play';
      if (animationTimeout) {
        clearTimeout(animationTimeout);
      }
    }

    function animate() {
      if (!isPlaying) return;

      if (currentTimeIndex < uniqueTimes.length - 1) {
        currentTimeIndex++;
        updateMapForTime(currentTimeIndex);
        
        const speed = parseInt(document.getElementById('playSpeed').value);
        animationTimeout = setTimeout(animate, speed);
      } else {
        // Animation finished
        stopAnimation();
      }
    }

    // Initialize the application
    loadData()
      .then(data => {
        const result = processData(data);
        currentData = result.processedData;
        setupControls();
        updateMapForTime(0);
        console.log('Barge tracker initialized successfully');
      })
      .catch(error => {
        console.error('Error initializing barge tracker:', error);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `Error loading data: ${error.message}<br>Please check that your barge_data.json file exists and is properly formatted.`;
        document.body.insertBefore(errorDiv, document.getElementById('map'));
      });
  </script>
</body>
</html>