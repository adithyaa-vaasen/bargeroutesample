<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Barge + Storm Tracker (2015–2025)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 85vh; }
    .header { padding: 10px 20px; background: #f0f0f0; border-bottom: 1px solid #ccc; }
    .controls { padding: 10px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .legend { display: flex; gap: 15px; padding: 5px 10px; background: #f8f8f8; border-radius: 4px; font-size: 13px; }
    .storm-legend { background: white; padding: 10px; border: 2px solid #ccc; border-radius: 6px; font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <h2>Maritime Risk Tracker</h2>
    <span>2015–2025 hurricanes (SID-based) replayed in 2027 | Intensity-colored tracks</span>
  </div>
  <div class="controls">
    <button id="playPauseBtn">Play</button>
    <select id="playSpeed">
      <option value="1000">Slow</option>
      <option value="500" selected>Normal</option>
      <option value="250">Fast</option>
    </select>
    <select id="bargeFilter"><option value="all">All Barges</option></select>
    <label><input type="checkbox" id="toggleStorms" checked> Storms</label>
    <input type="range" id="timeSlider" style="width: 300px;" />
    <span id="currentTime" style="font-weight: bold;">Loading...</span>
    <div class="legend" id="legend"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const colors = ['#E74C3C', '#5DADE2', '#4CA61C', '#161CB0', '#FFA500', '#800080', '#FF69B4', '#A52A2A', '#00CED1', '#228B22'];
    let currentData = [], stormData = { points: {}, metadata: {} };
    let uniqueTimes = [];
    let bargeMarkers = {}, bargePaths = {}, stormSegmentGroups = {};
    let isPlaying = false, currentTimeIndex = 0, animationTimeout;
    let selectedBarge = 'all';

    const map = L.map('map', { zoomControl: false });
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png').addTo(map);
    L.control.zoom({ position: 'topright' }).addTo(map);

    function getStormColor(wind) {
      if (!wind || wind < 34) return "#E2ECE2";
      if (wind < 39) return "#00FF00";
      if (wind < 64) return "#FFFF00";
      if (wind < 83) return "#FFA500";
      if (wind < 96) return "#FF6347";
      if (wind < 113) return "#FF0000";
      if (wind < 137) return "#FF1493";
      return "#8B008B";
    }

    function loadData() {
      return Promise.all([
        fetch('/barge_data.json').then(r => r.ok ? r.json() : []).catch(() => []),
        fetch('/storms_2015_2025.json').then(r => r.ok ? r.json() : []).catch(() => [])
      ]);
    }

    function processData(bargeRaw = [], stormJSON = []) {
      console.log('Barge records:', Array.isArray(bargeRaw) ? bargeRaw.length : 0);

      // === BARGES ===
      const processedBarge = (Array.isArray(bargeRaw) ? bargeRaw : [])
        .map(d => ({ ...d, Timestamp: new Date(d.Timestamp).toISOString() }))
        .filter(d => d.Latitude && d.Longitude)
        .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));

      const barges = [...new Set(processedBarge.map(d => d['Barge Name']))].sort();
      const colorDict = {};
      barges.forEach((b, i) => colorDict[b] = colors[i % colors.length]);

      // === STORMS (USE SID) ===
      const features = stormJSON.features || [];
      console.log('Storm features:', features.length);

      features.forEach(f => {
        const p = f.properties;
        const sid = p.SID;
        if (!sid) return;

        if (!stormData.metadata[sid]) {
          stormData.metadata[sid] = { name: p.name, year: new Date(p.time).getUTCFullYear() };
        }
        if (!stormData.points[sid]) stormData.points[sid] = [];

        stormData.points[sid].push({
          time: p.time,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0],
          wind: p.wind,
          color: getStormColor(p.wind)
        });
      });

      Object.values(stormData.points).forEach(arr => arr.sort((a, b) => new Date(a.time) - new Date(b.time)));

      // === REBASE TO 2027 ===
      const rebaseYear = 2027;
      Object.keys(stormData.points).forEach(sid => {
        const firstYear = new Date(stormData.points[sid][0].time).getUTCFullYear();
        const offset = rebaseYear - firstYear;
        stormData.points[sid].forEach(p => {
          const d = new Date(p.time);
          d.setUTCFullYear(d.getUTCFullYear() + offset);
          p.time = d.toISOString();
        });
      });

      // === TIME MERGING ===
      const allTimes = new Set();
      processedBarge.forEach(d => allTimes.add(d.Timestamp));
      Object.values(stormData.points).flat().forEach(p => allTimes.add(p.time));
      uniqueTimes = Array.from(allTimes).sort();

      // === MAP CENTER ===
      const valid = processedBarge.filter(d => d.Latitude && d.Longitude);
      if (valid.length > 0) {
        const avgLat = valid.reduce((s, d) => s + d.Latitude, 0) / valid.length;
        const avgLon = valid.reduce((s, d) => s + d.Longitude, 0) / valid.length;
        map.setView([avgLat, avgLon], 5);
      } else {
        map.setView([30, -90], 3);
      }

      // === LEGEND ===
      const legend = document.getElementById('legend');
      barges.forEach(b => {
        legend.innerHTML += `<span style="color:${colorDict[b]};font-weight:bold;">Barge: ${b}</span> `;
      });
      document.getElementById('bargeFilter').innerHTML = '<option value="all">All Barges</option>' +
        barges.map(b => `<option value="${b}">${b}</option>`).join('');

      // === MARKERS & PATHS ===
      barges.forEach(b => {
        bargeMarkers[b] = L.marker([0,0], { icon: L.divIcon({ html: `<div style="width:12px;height:8px;background:${colorDict[b]};border:1px solid #000;border-radius:2px;"></div>`, iconSize: [12,8], iconAnchor: [6,4] }) });
        bargePaths[b] = L.polyline([], { color: colorDict[b], weight: 3, opacity: 0.6 }).addTo(map);
      });

      Object.keys(stormData.points).forEach(sid => {
        stormSegmentGroups[sid] = L.featureGroup().addTo(map);
      });

      // === STORM LEGEND ===
      const legendCtrl = L.control({ position: 'bottomleft' });
      legendCtrl.onAdd = () => {
        const div = L.DomUtil.create('div', 'storm-legend');
        div.innerHTML = '<strong>Intensity</strong><br>' +
          'Non-TD: #E2ECE2<br>TD: #00FF00<br>TS: #FFFF00<br>Cat 1: #FFA500<br>Cat 2: #FF6347<br>Cat 3: #FF0000<br>Cat 4: #FF1493<br>Cat 5: #8B008B'.replace(/#([0-9A-F]{6})/g, '<i style="background:$1;width:12px;height:12px;display:inline-block;margin-right:5px;"></i>');
        return div;
      };
      legendCtrl.addTo(map);

      return { processedBarge, barges, colorDict };
    }

    function updateMapForTime(timeIndex) {
      const now = new Date(uniqueTimes[timeIndex]);

      // === BARGES ===
      Object.keys(bargeMarkers).forEach(barge => {
        const marker = bargeMarkers[barge];
        const path = bargePaths[barge];
        const history = currentData.filter(d => d['Barge Name'] === barge && new Date(d.Timestamp) <= now)
          .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
        const passedEnd = history.length > 0 && now > new Date(history[history.length-1].Timestamp);

        if (history.length > 0 && !passedEnd && (selectedBarge === 'all' || selectedBarge === barge)) {
          const pos = history[history.length-1];
          marker.setLatLng([pos.Latitude, pos.Longitude]).addTo(map);
          marker.bindTooltip(`${barge}<br>${new Date(pos.Timestamp).toLocaleDateString()}`, { direction: 'top' });
          path.setLatLngs(history.map(p => [p.Latitude, p.Longitude]));
        } else {
          map.removeLayer(marker);
          path.setStyle({ opacity: selectedBarge === barge ? 0.6 : 0 });
        }
      });

      // === STORMS (SID + INTENSITY) ===
      const showStorms = document.getElementById('toggleStorms').checked;
      Object.keys(stormSegmentGroups).forEach(sid => {
        const group = stormSegmentGroups[sid];
        const points = stormData.points[sid] || [];
        const meta = stormData.metadata[sid];
        const visible = points.filter(p => new Date(p.time) <= now);

        group.clearLayers();
        if (!showStorms || visible.length < 2) return;

        for (let i = 0; i < visible.length - 1; i++) {
          const curr = visible[i], next = visible[i+1];
          const seg = L.polyline([[curr.lat, curr.lon], [next.lat, next.lon]], {
            color: curr.color, weight: 4, opacity: 0.9
          });
          seg.bindTooltip(
            `<strong>${meta.name} (${meta.year})</strong><br>` +
            `SID: ${sid}<br>` +
            `Date: ${new Date(curr.time).toLocaleDateString()}<br>` +
            `Wind: ${curr.wind} kt`,
            { sticky: true }
          );
          group.addLayer(seg);
        }
      });

      document.getElementById('currentTime').textContent = now.toLocaleDateString();
      document.getElementById('timeSlider').value = timeIndex;
    }

    function setupControls() {
      const slider = document.getElementById('timeSlider');
      slider.min = 0; slider.max = uniqueTimes.length - 1; slider.value = 0;
      slider.addEventListener('input', e => { currentTimeIndex = +e.target.value; updateMapForTime(currentTimeIndex); if (isPlaying) stopAnimation(); });
      document.getElementById('playPauseBtn').onclick = () => isPlaying ? stopAnimation() : startAnimation();
      document.getElementById('bargeFilter').onchange = e => { selectedBarge = e.target.value; updateMapForTime(currentTimeIndex); };
      document.getElementById('toggleStorms').onchange = () => updateMapForTime(currentTimeIndex);
    }

    function startAnimation() { isPlaying = true; document.getElementById('playPauseBtn').textContent = 'Pause'; animate(); }
    function stopAnimation() { isPlaying = false; document.getElementById('playPauseBtn').textContent = 'Play'; clearTimeout(animationTimeout); }
    function animate() {
      if (!isPlaying || currentTimeIndex >= uniqueTimes.length - 1) return stopAnimation();
      currentTimeIndex++;
      updateMapForTime(currentTimeIndex);
      animationTimeout = setTimeout(animate, +document.getElementById('playSpeed').value);
    }

    loadData().then(([bargeRaw, stormJSON]) => {
      const { processedBarge } = processData(bargeRaw, stormJSON);
      currentData = processedBarge;
      setupControls();
      updateMapForTime(0);
      console.log('Ready: SID-based storms + intensity segments');
    }).catch(err => {
      document.body.innerHTML += `<div style="color:red;padding:20px;">Error: ${err.message}</div>`;
    });
  </script>
</body>
</html>