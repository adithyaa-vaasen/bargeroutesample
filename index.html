<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Barge + Hurricane Tracker (2027)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 85vh; }
    .tooltip { background: white; border: 1px solid #ccc; border-radius: 4px; padding: 5px; }
    .header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f5f5f5; border-bottom: 1px solid #ccc; }
    .controls { padding: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .legend { display: flex; gap: 15px; padding: 5px 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; flex-wrap: wrap; }
    .error-message { background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin: 10px; }
    .storm-legend { background: white; padding: 10px; border: 2px solid #ccc; border-radius: 6px; font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <h2>Barge & Hurricane Tracker (2027)</h2>
    <span>Slide through time to view barge routes and hurricane tracks</span>
  </div>
  <div class="controls">
    <button id="playPauseBtn">Play</button>
    <label>
      Speed:
      <select id="playSpeed">
        <option value="1000">Slow</option>
        <option value="500" selected>Normal</option>
        <option value="250">Fast</option>
        <option value="100">Very Fast</option>
      </select>
    </label>
    <label>
      Filter Barge:
      <select id="bargeFilter">
        <option value="all">All Barges</option>
      </select>
    </label>
    <label>
      <input type="checkbox" id="toggleStorms" checked> Show Hurricanes
    </label>
    <input type="range" id="timeSlider" style="width: 300px;" />
    <span id="currentTime" style="font-weight: bold;">Loading...</span>
    <div class="legend" id="legend"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // === GLOBALS ===
    const colors = ['#E74C3C', '#5DADE2', '#4CA61C', '#161CB0', '#FFA500', '#800080', '#FF69B4', '#A52A2A', '#00CED1', '#228B22', '#4682B4', '#FFD700'];
    let currentData = [], stormData = { points: {}, lines: {} };
    let uniqueTimes = [];
    let bargeMarkers = {}, bargePaths = {};
    let stormMarkers = {}, stormPaths = {};
    let isPlaying = false, currentTimeIndex = 0, animationTimeout;
    let selectedBarge = 'all';

    // === MAP SETUP ===
    const map = L.map('map', { zoomControl: false });
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    }).addTo(map);
    L.control.zoom({ position: 'topright' }).addTo(map);

    // === DATA LOADING (ROBUST) ===
    function loadData() {
      return Promise.all([
        fetch('/barge_data.json')
          .then(r => {
            if (!r.ok) {
              console.warn('barge_data.json not found:', r.status);
              return [];
            }
            return r.json();
          })
          .catch(err => {
            console.warn('Fetch barge_data.json failed:', err);
            return [];
          }),
        fetch('/storms_2027.json')
          .then(r => {
            if (!r.ok) {
              console.warn('storms_2027.json not found:', r.status);
              return { points: [], lines: [] };
            }
            return r.json();
          })
          .catch(err => {
            console.warn('Fetch storms_2027.json failed:', err);
            return { points: [], lines: [] };
          })
      ]);
    }

    function processData(bargeRaw = [], stormJSON = { points: [], lines: [] }) {
      console.log('RAW DATA â†’ Barge:', Array.isArray(bargeRaw) ? bargeRaw.length : 'NOT ARRAY', 
                  '| Storm points:', stormJSON.points?.length || 0);

      // === BARGE DATA ===
      const processedBarge = (Array.isArray(bargeRaw) ? bargeRaw : [])
        .map(d => ({ ...d, Timestamp: new Date(d.Timestamp).toISOString() }))
        .filter(d => d.Latitude && d.Longitude && d.Latitude !== 0 && d.Longitude !== 0)
        .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));

      const barges = [...new Set(processedBarge.map(d => d['Barge Name']))].sort();
      const colorDict = {};
      barges.forEach((b, i) => colorDict[b] = colors[i % colors.length]);

      // === STORM DATA ===
      stormJSON.points.forEach(f => {
        const name = f.properties.name;
        if (!stormData.points[name]) stormData.points[name] = [];
        stormData.points[name].push({
          time: f.properties.time,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0],
          category: f.properties.category,
          wind: f.properties.wind,
          color: f.properties.color
        });
      });
      Object.values(stormData.points).forEach(arr => arr.sort((a, b) => new Date(a.time) - new Date(b.time)));

      stormJSON.lines.forEach(f => {
        const name = f.properties.name;
        if (!stormData.lines[name]) stormData.lines[name] = [];
        stormData.lines[name].push({
          time: f.properties.time,
          coords: f.geometry.coordinates,
          color: f.properties.color
        });
      });

      // === TIME MERGING + CENTERING ===
      const allTimes = new Set();
      processedBarge.forEach(d => allTimes.add(d.Timestamp));
      stormJSON.points.forEach(f => allTimes.add(f.properties.time));
      uniqueTimes = Array.from(allTimes).sort();
      if (uniqueTimes.length > 0) {
        const last = new Date(uniqueTimes[uniqueTimes.length - 1]);
        last.setDate(last.getDate() + 1);
        uniqueTimes.push(last.toISOString());
      }

      const valid = processedBarge.filter(d => d.Latitude && d.Longitude);
      if (valid.length > 0) {
        const avgLat = valid.reduce((s, d) => s + d.Latitude, 0) / valid.length;
        const avgLon = valid.reduce((s, d) => s + d.Longitude, 0) / valid.length;
        map.setView([avgLat, avgLon], 5);
      } else {
        map.setView([30, -90], 3);
      }

      // === LEGEND ===
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      barges.forEach(b => {
        const s = document.createElement('span');
        s.innerHTML = `<span style="color: ${colorDict[b]}; font-weight: bold;">Barge: ${b}</span>`;
        legend.appendChild(s);
      });

      const filter = document.getElementById('bargeFilter');
      barges.forEach(b => {
        const opt = document.createElement('option');
        opt.value = b; opt.textContent = b;
        filter.appendChild(opt);
      });

      // === MARKERS & PATHS ===
      barges.forEach(b => {
        bargeMarkers[b] = L.marker([0, 0], {
          icon: L.divIcon({
            className: 'barge-rect',
            html: `<div style="width:12px;height:8px;background:${colorDict[b]};border:1px solid black;border-radius:2px;"></div>`,
            iconSize: [12, 8], iconAnchor: [6, 4]
          })
        });
        bargePaths[b] = L.polyline([], { color: colorDict[b], weight: 3, opacity: 0.6 }).addTo(map);
      });

      Object.keys(stormData.points).forEach(name => {
        stormMarkers[name] = L.circleMarker([0, 0], {
          radius: 7, fillColor: '#888', color: '#000', weight: 1, fillOpacity: 0.9
        });
        stormPaths[name] = L.polyline([], { weight: 3, opacity: 0.7 }).addTo(map);
      });

      // === STORM LEGEND ===
      const stormCats = [
        { name: "Non-TD", color: "#E2ECE2" }, { name: "TD", color: "#00FF00" },
        { name: "TS", color: "#FFFF00" }, { name: "Cat 1", color: "#FFA500" },
        { name: "Cat 2", color: "#FF6347" }, { name: "Cat 3", color: "#FF0000" },
        { name: "Cat 4", color: "#FF1493" }, { name: "Cat 5", color: "#8B008B" }
      ];
      const legendCtrl = L.control({ position: 'bottomleft' });
      legendCtrl.onAdd = () => {
        const div = L.DomUtil.create('div', 'storm-legend');
        div.innerHTML = '<strong>Hurricane Intensity</strong><br>' + stormCats.map(c =>
          `<p><i style="background:${c.color};width:12px;height:12px;display:inline-block;margin-right:5px;"></i> ${c.name}</p>`
        ).join('');
        return div;
      };
      legendCtrl.addTo(map);

      return { processedBarge, barges, colorDict };
    }

    function updateMapForTime(timeIndex) {
      const currentTime = uniqueTimes[timeIndex];
      const now = new Date(currentTime);

      // === UPDATE BARGES ===
      Object.keys(bargeMarkers).forEach(barge => {
        const marker = bargeMarkers[barge];
        const path = bargePaths[barge];

        const history = currentData
          .filter(d => d['Barge Name'] === barge && new Date(d.Timestamp) <= now)
          .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));

        const allData = currentData.filter(d => d['Barge Name'] === barge);
        const lastPoint = allData[allData.length - 1];
        const passedEnd = lastPoint && now > new Date(lastPoint.Timestamp);

        if (history.length > 0 && !passedEnd && (selectedBarge === 'all' || selectedBarge === barge)) {
          const pos = history[history.length - 1];
          marker.setLatLng([pos.Latitude, pos.Longitude]).addTo(map);
          marker.bindTooltip(`${barge}<br>${pos.Location || 'N/A'}<br>${new Date(pos.Timestamp).toLocaleDateString()}`, {
            direction: 'top', offset: [0, -10]
          });
          path.setLatLngs(history.map(p => [p.Latitude, p.Longitude]));
          path.setStyle({ opacity: 0.6 });
        } else {
          if (map.hasLayer(marker)) map.removeLayer(marker);
          path.setStyle({ opacity: selectedBarge === barge ? 0.6 : 0 });
        }
      });

      // === UPDATE HURRICANES ===
      const showStorms = document.getElementById('toggleStorms').checked;
      Object.keys(stormMarkers).forEach(name => {
        const marker = stormMarkers[name];
        const path = stormPaths[name];
        const points = stormData.points[name] || [];
        const lines = stormData.lines[name] || [];

        const activePoint = points.find(p => new Date(p.time) <= now);
        const hasFuture = points.some(p => new Date(p.time) > now);

        const visibleLines = lines.filter(l => new Date(l.time) <= now);
        const pathCoords = visibleLines.flatMap(l => l.coords);

        if (showStorms && activePoint && !hasFuture) {
          marker.setLatLng([activePoint.lat, activePoint.lon]).addTo(map);
          marker.setStyle({ fillColor: activePoint.color });
          marker.bindTooltip(`${name}<br>${activePoint.category}${activePoint.wind ? `<br>Wind: ${activePoint.wind} kt` : ''}`, {
            direction: 'top', offset: [0, -10]
          });
          path.setLatLngs(pathCoords);
          path.setStyle({ color: activePoint.color, opacity: 0.7 });
        } else {
          if (map.hasLayer(marker)) map.removeLayer(marker);
          path.setStyle({ opacity: 0 });
        }
      });

      document.getElementById('currentTime').textContent = now.toLocaleDateString();
      document.getElementById('timeSlider').value = timeIndex;
    }

    // === CONTROLS ===
    function setupControls() {
      const timeSlider = document.getElementById('timeSlider');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const playSpeed = document.getElementById('playSpeed');
      const bargeFilter = document.getElementById('bargeFilter');
      const toggleStorms = document.getElementById('toggleStorms');

      timeSlider.min = 0;
      timeSlider.max = uniqueTimes.length - 1;
      timeSlider.value = 0;

      timeSlider.addEventListener('input', e => {
        currentTimeIndex = parseInt(e.target.value);
        updateMapForTime(currentTimeIndex);
        if (isPlaying) stopAnimation();
      });

      playPauseBtn.addEventListener('click', () => isPlaying ? stopAnimation() : startAnimation());
      bargeFilter.addEventListener('change', e => { selectedBarge = e.target.value; updateMapForTime(currentTimeIndex); });
      toggleStorms.addEventListener('change', () => updateMapForTime(currentTimeIndex));
    }

    function startAnimation() {
      isPlaying = true;
      document.getElementById('playPauseBtn').textContent = 'Pause';
      animate();
    }
    function stopAnimation() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = 'Play';
      clearTimeout(animationTimeout);
    }
    function animate() {
      if (!isPlaying) return;
      if (currentTimeIndex < uniqueTimes.length - 1) {
        currentTimeIndex++;
        updateMapForTime(currentTimeIndex);
        animationTimeout = setTimeout(animate, parseInt(document.getElementById('playSpeed').value));
      } else {
        stopAnimation();
      }
    }

    // === INIT ===
    loadData()
      .then(([bargeRaw, stormJSON]) => {
        const { processedBarge } = processData(bargeRaw, stormJSON);
        currentData = processedBarge;
        setupControls();
        updateMapForTime(0);
        console.log('Tracker initialized with barge + hurricane tracks');
      })
      .catch(err => {
        console.error('Init error:', err);
        const div = document.createElement('div');
        div.className = 'error-message';
        div.innerHTML = `Error: ${err.message}`;
        document.body.insertBefore(div, document.getElementById('map'));
      });
  </script>
</body>
</html>