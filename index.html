<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Barge Schedule Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 85vh; }
    .tooltip { background: white; border: 1px solid #ccc; border-radius: 4px; padding: 5px; }
    .header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f5f5f5; border-bottom: 1px solid #ccc; }
    .controls { padding: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .legend { display: flex; gap: 15px; padding: 5px 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; flex-wrap: wrap; }
    .error-message { background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin: 10px; }
  </style>
</head>
<body>
  <div class="header">
    <h2>Barge Tracker</h2>
    <span>Slide through dates to view barge movements</span>
  </div>
  <div class="controls">
    <button id="playPauseBtn">▶️ Play</button>
    <label>
      Speed:
      <select id="playSpeed">
        <option value="1000">Slow</option>
        <option value="500" selected>Normal</option>
        <option value="250">Fast</option>
        <option value="100">Very Fast</option>
      </select>
    </label>
    <label>
      Filter Barge:
      <select id="bargeFilter">
        <option value="all">All Barges</option>
      </select>
    </label>
    <input type="range" id="timeSlider" style="width: 300px;" />
    <span id="currentTime" style="font-weight: bold;">Loading...</span>
    <div class="legend" id="legend"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Sample data for demo
    const sampleData = [];

    // Initialize map
    const map = L.map('map', { zoomControl: false });
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    }).addTo(map);
    L.control.zoom({ position: 'topright' }).addTo(map);

    // Colors for barges
    const colors = ['#E74C3C', '#5DADE2', '#4CA61C', '#161CB0', '#FFA500', '#800080', '#FF69B4', '#A52A2A', '#00CED1', '#228B22', '#4682B4', '#FFD700'];

    // Global variables
    let currentData = [];
    let uniqueTimes = [];
    let bargeMarkers = {};
    let bargePaths = {};
    let isPlaying = false;
    let currentTimeIndex = 0;
    let animationTimeout;
    let selectedBarge = 'all';

    function loadData() {
      return fetch('/barge_data.json')
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to load barge_data.json');
          }
          return response.json();
        })
        .catch(error => {
          console.warn('Could not load barge_data.json, using sample data:', error);
          return sampleData;
        });
    }

    function processData(data) {
      console.log('Processing data:', data);
      
      if (!data || !Array.isArray(data) || data.length === 0) {
        throw new Error('No valid data available');
      }

      // Convert timestamps and filter invalid positions
      const processedData = data
        .map(d => ({
          ...d,
          Timestamp: new Date(d.Timestamp).toISOString()
        }))
        .filter(d => d.Latitude !== 0 && d.Longitude !== 0 && d.Latitude != null && d.Longitude != null)
        .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));

      // Get unique times and add one more timestamp at the end for cleanup
      uniqueTimes = [...new Set(processedData.map(d => d.Timestamp))].sort();
      
      // Add a timestamp 1 day after the last timestamp so barges can disappear
      if (uniqueTimes.length > 0) {
        const lastTime = new Date(uniqueTimes[uniqueTimes.length - 1]);
        lastTime.setDate(lastTime.getDate() + 1);
        uniqueTimes.push(lastTime.toISOString());
      }
      
      // Get unique barges
      const barges = [...new Set(processedData.map(d => d['Barge Name']))].sort();
      
      // Create color mapping
      const colorDict = {};
      barges.forEach((barge, i) => {
        colorDict[barge] = colors[i % colors.length];
      });

      // Set map center
      const avgLat = processedData.reduce((sum, d) => sum + d.Latitude, 0) / processedData.length;
      const avgLon = processedData.reduce((sum, d) => sum + d.Longitude, 0) / processedData.length;
      map.setView([avgLat, avgLon], 4);

      // Create legend
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      barges.forEach(barge => {
        const span = document.createElement('span');
        span.innerHTML = `<span style="color: ${colorDict[barge]}; font-weight: bold;">■ ${barge}</span>`;
        legend.appendChild(span);
      });

      // Populate barge filter dropdown
      const bargeFilter = document.getElementById('bargeFilter');
      barges.forEach(barge => {
        const option = document.createElement('option');
        option.value = barge;
        option.textContent = barge;
        bargeFilter.appendChild(option);
      });

      // Initialize markers and paths for each barge
      barges.forEach(barge => {
        bargeMarkers[barge] = L.marker([0, 0], {
          icon: L.divIcon({
            className: 'barge-rectangle',
            html: `<div style="
              width: 10px; 
              height: 6px; 
              background-color: ${colorDict[barge]}; 
              border: 1px solid black;
              border-radius: 2px;
            "></div>`,
            iconSize: [10, 6],
            iconAnchor: [8, 5]
          })
        });

        bargePaths[barge] = L.polyline([], {
          color: colorDict[barge],
          weight: 3,
          opacity: 0.6
        }).addTo(map);
      });

      return { processedData, barges, colorDict };
    }

    function updateMapForTime(timeIndex) {
      const currentTime = uniqueTimes[timeIndex];

      // For each barge, determine if it should be visible and where
      Object.keys(bargeMarkers).forEach(barge => {
        const marker = bargeMarkers[barge];
        
        // Get all data for this barge up to current time
        const bargeDataUpToNow = currentData
          .filter(d => d['Barge Name'] === barge && new Date(d.Timestamp) <= new Date(currentTime))
          .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
        
        // Get all data for this barge to find last data point
        const allBargeData = currentData
          .filter(d => d['Barge Name'] === barge)
          .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
        
        const lastDataPoint = allBargeData[allBargeData.length - 1];
        const currentTimeDate = new Date(currentTime);
        const lastDataDate = lastDataPoint ? new Date(lastDataPoint.Timestamp) : null;
        
        // Check if current time is beyond the last data point for this barge
        const passedLastDataPoint = lastDataDate && currentTimeDate > lastDataDate;
        
        // Show or hide barge based on conditions
        if (bargeDataUpToNow.length > 0 && !passedLastDataPoint && (selectedBarge === 'all' || selectedBarge === barge)) {
          // Show barge at its most recent known position
          const mostRecentPosition = bargeDataUpToNow[bargeDataUpToNow.length - 1];
          marker.setLatLng([mostRecentPosition.Latitude, mostRecentPosition.Longitude]);
          marker.addTo(map);
          marker.bindTooltip(`${barge}<br>Step: ${mostRecentPosition['Schedule Step'] || 'N/A'}<br>Location: ${mostRecentPosition.Location || 'N/A'}<br>Date: ${new Date(mostRecentPosition.Timestamp).toLocaleDateString()}`, {
            direction: 'top',
            offset: [0, -10]
          });
        } else {
          // Hide barge
          map.removeLayer(marker);
        }

        // Update path
        if (selectedBarge === 'all' || selectedBarge === barge) {
          const bargeHistory = currentData
            .filter(d => d['Barge Name'] === barge && new Date(d.Timestamp) <= new Date(currentTime))
            .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
          
          const pathCoords = bargeHistory.map(d => [d.Latitude, d.Longitude]);
          bargePaths[barge].setLatLngs(pathCoords);
          bargePaths[barge].setStyle({ opacity: 0.6 });
        } else {
          bargePaths[barge].setStyle({ opacity: 0 });
        }
      });

      // Update time display
      document.getElementById('currentTime').textContent = new Date(currentTime).toLocaleDateString();
      document.getElementById('timeSlider').value = timeIndex;
    }

    function setupControls() {
      const timeSlider = document.getElementById('timeSlider');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const playSpeed = document.getElementById('playSpeed');
      const bargeFilter = document.getElementById('bargeFilter');

      if (!timeSlider || !playPauseBtn || !playSpeed || !bargeFilter) {
        console.error('One or more control elements not found');
        return;
      }

      timeSlider.min = 0;
      timeSlider.max = uniqueTimes.length - 1;
      timeSlider.value = 0;

      timeSlider.addEventListener('input', (e) => {
        currentTimeIndex = parseInt(e.target.value);
        updateMapForTime(currentTimeIndex);
        if (isPlaying) {
          stopAnimation();
        }
      });

      playPauseBtn.addEventListener('click', () => {
        if (isPlaying) {
          stopAnimation();
        } else {
          startAnimation();
        }
      });

      bargeFilter.addEventListener('change', (e) => {
        selectedBarge = e.target.value;
        updateMapForTime(currentTimeIndex);
      });
    }

    function startAnimation() {
      isPlaying = true;
      document.getElementById('playPauseBtn').textContent = '⏸ Pause';
      animate();
    }

    function stopAnimation() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '▶️ Play';
      if (animationTimeout) {
        clearTimeout(animationTimeout);
      }
    }

    function animate() {
      if (!isPlaying) return;

      if (currentTimeIndex < uniqueTimes.length - 1) {
        currentTimeIndex++;
        updateMapForTime(currentTimeIndex);
        
        const speed = parseInt(document.getElementById('playSpeed').value);
        animationTimeout = setTimeout(animate, speed);
      } else {
        stopAnimation();
      }
    }

    // Initialize the application
    loadData()
      .then(data => {
        const result = processData(data);
        currentData = result.processedData;
        setupControls();
        updateMapForTime(0);
        console.log('Barge tracker initialized successfully');
      })
      .catch(error => {
        console.error('Error initializing barge tracker:', error);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `Error loading data: ${error.message}<br>Please check that your barge_data.json file exists and is properly formatted.`;
        document.body.insertBefore(errorDiv, document.getElementById('map'));
      });
  </script>
</body>
</html>